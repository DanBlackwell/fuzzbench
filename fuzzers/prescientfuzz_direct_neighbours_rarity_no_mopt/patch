diff --git a/fuzzers/fuzzbench/src/lib.rs b/fuzzers/fuzzbench/src/lib.rs
index e63325d8..5e00b8ed 100644
--- a/fuzzers/fuzzbench/src/lib.rs
+++ b/fuzzers/fuzzbench/src/lib.rs
@@ -322,13 +322,15 @@ fn fuzz(
     // Setup a randomic Input2State stage
     let i2s = StdMutationalStage::new(StdScheduledMutator::new(tuple_list!(I2SRandReplace::new())));
 
-    // Setup a MOPT mutator
-    let mutator = StdMOptMutator::new(
-        &mut state,
-        havoc_mutations().merge(tokens_mutations()),
-        7,
-        5,
-    )?;
+    // // Setup a MOPT mutator
+    // let mutator = StdMOptMutator::new(
+    //     &mut state,
+    //     havoc_mutations().merge(tokens_mutations()),
+    //     7,
+    //     5,
+    // )?;
+    // Setup a mutational stage with a basic bytes mutator
+    let mutator = StdScheduledMutator::with_max_stack_pow(havoc_mutations().merge(tokens_mutations()), 6);
 
     let mutation = StdMutationalStage::with_max_iterations(mutator, 1024);
 
diff --git a/libafl/src/schedulers/prescient_weighted.rs b/libafl/src/schedulers/prescient_weighted.rs
index 6761c534..1879e0b3 100644
--- a/libafl/src/schedulers/prescient_weighted.rs
+++ b/libafl/src/schedulers/prescient_weighted.rs
@@ -270,13 +270,13 @@ where
             let idx_meta = tc.metadata::<MapIndexesMetadata>().unwrap();
             for reachability in reachabilities {
                 // Only keep this if it's the best depth we've seen for this edge
-                if reachability.depth == reachable_blocks_result.least_depth_for_index[&reachability.index] {
+                if reachability.depth == 1 { // reachable_blocks_result.least_depth_for_index[&reachability.index] {
                     let freq = reachable_blocks_result.frequency_for_reachability.get(&reachability);
                     if freq.is_none() { println!("frequency is none for {:?}", reachability); }
                     let rarity = 1f64 / *freq.unwrap() as f64;
-                    let backoff_weighting = backoff_weighting_for_direct_neighbour.get(&reachability.direct_neighbour_ancestor_index);
+                    let backoff_weighting = Some(1f64); // backoff_weighting_for_direct_neighbour.get(&reachability.direct_neighbour_ancestor_index);
                     if backoff_weighting.is_none() { println!("backoff_weighting is none for {:?}", reachability.direct_neighbour_ancestor_index); }
-                    neighbour_score += backoff_weighting.unwrap() * rarity * 1f64 / reachability.depth as f64;
+                    neighbour_score += backoff_weighting.unwrap() * rarity; // * 1f64 / reachability.depth as f64;
                     reachability_favored |= favored_filled.insert(reachability.index);
                 }
             }
